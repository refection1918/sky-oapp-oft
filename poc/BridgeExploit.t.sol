// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { OptionsBuilder } from "@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol";

interface ISkyOFTAdapter {
    struct SendParam {
        uint32 dstEid;
        bytes32 to;
        uint256 amountLD;
        uint256 minAmountLD;
        bytes extraOptions;
        bytes composeMsg;
        bytes oftCmd;
    }
    struct MessagingFee {
        uint256 nativeFee;
        uint256 lzTokenFee;
    }
    
    struct RateLimitConfig {
        uint32 eid;
        uint48 window;
        uint256 limit;
    }
    function send(SendParam calldata _sendParam, MessagingFee calldata _fee, address _refundAddress) external payable;
    function token() external view returns (address);
    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);
    function setRateLimitAccountingType(uint8 _type) external; // 0=Net, 1=Gross
    function owner() external view returns (address);
    function setPeer(uint32 _eid, bytes32 _peer) external;
    function setRateLimits(RateLimitConfig[] calldata _rateLimitConfigsInbound, RateLimitConfig[] calldata _rateLimitConfigsOutbound) external;
}

interface IGovernanceOAppSender {
    struct TxParams {
        uint32 dstEid;
        bytes32 dstTarget;
        bytes dstCallData;
        bytes extraOptions;
    }
    struct MessagingFee {
        uint256 nativeFee;
        uint256 lzTokenFee;
    }
    function sendTx(TxParams calldata _params, MessagingFee calldata _fee, address _refundAddress) external payable;
}

contract BridgeExploitTest is Test {
    using OptionsBuilder for bytes;
    ISkyOFTAdapter public skyOft;
    IERC20 public usds;
    IGovernanceOAppSender public govSender;
    
    // Mainnet addresses
    address constant SKY_OFT_ADAPTER = 0x1e1D42781FC170EF9da004Fb735f56F0276d01B8;
    address constant GOV_SENDER = 0x27FC1DD771817b53bE48Dc28789533BEa53C9CCA;
    uint32 constant DST_EID = 30110; // Arbitrum V2 (Example)

    address public attacker = address(0x1337);
    address public whale = 0x47eCc0Db9c727d9A4c097e6be44D930591462058; // Known USDS/DAI holder or finding one dynamically

    function setUp() public {
        vm.createSelectFork(vm.envString("ETH_RPC_URL"));
        skyOft = ISkyOFTAdapter(SKY_OFT_ADAPTER);
        usds = IERC20(skyOft.token());
        govSender = IGovernanceOAppSender(GOV_SENDER);
        
        // Fund attacker
        deal(address(usds), attacker, 1_000_000 * 1e18);
        vm.deal(attacker, 100 ether);

        // Setup Peer and Owner
        address owner = skyOft.owner();
        console.log("Owner:", owner);
        vm.startPrank(owner);
        skyOft.setPeer(DST_EID, bytes32(uint256(uint160(address(this))))); // Set test contract as peer
        
        // Set Rate Limits to allowed for testing
        ISkyOFTAdapter.RateLimitConfig[] memory configs = new ISkyOFTAdapter.RateLimitConfig[](1);
        configs[0] = ISkyOFTAdapter.RateLimitConfig({
            eid: DST_EID,
            limit: 1_000_000_000 * 1e18, // 1B Limit
            window: 1 days
        });
        skyOft.setRateLimits(new ISkyOFTAdapter.RateLimitConfig[](0), configs); // Set Outbound
        vm.stopPrank();
    }

    function test_NetAccounting_InfiniteVol() public {
        console.log("=== S6: Net Accounting Verification ===");
        
        // Simulating locked funds on L2 (Inbound Capacity)
        // Since we are forking Mainnet, we can't easily simulate INBOUND messages without mocking the Endpoint.
        // However, we can simulate OUTBOUND messages (Locking).
        
        vm.startPrank(attacker);
        usds.approve(address(skyOft), type(uint256).max);
        
        uint256 amount = 1000 * 1e18;
        
        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        
        ISkyOFTAdapter.SendParam memory sendParam = ISkyOFTAdapter.SendParam({
            dstEid: DST_EID,
            to: bytes32(uint256(uint160(attacker))),
            amountLD: amount,
            minAmountLD: amount,
            extraOptions: options,
            composeMsg: "",
            oftCmd: ""
        });
        
        ISkyOFTAdapter.MessagingFee memory fee = skyOft.quoteSend(sendParam, false);
        
        console.log("Sending Outbound (Locking) 1000 USDS...");
        skyOft.send{value: fee.nativeFee}(sendParam, fee, attacker);
        console.log("Sent 1.");
        
        // Ideally, if we could MOCK an inbound message, we could prove we can unlock and relock.
        // Since we can't easily mock LZ Endpoint without complex setup, 
        // we will verify that Rate Limits exist by trying to send HUGE amount.
        
        uint256 hugeAmount = 1_000_000_000 * 1e18; // 1B USDS
        deal(address(usds), attacker, hugeAmount);
        
        sendParam.amountLD = hugeAmount;
        sendParam.minAmountLD = hugeAmount;
        
        try skyOft.quoteSend(sendParam, false) returns (ISkyOFTAdapter.MessagingFee memory hugeFee) {
             console.log("Quote successful for 1B USDS (Rate Limit might be huge or not enforced view-side)");
             // Try sending
             try skyOft.send{value: hugeFee.nativeFee}(sendParam, hugeFee, attacker) {
                 console.log("Sent 1B USDS!");
             } catch {
                 console.log("Failed to send 1B USDS (Likely Rate Limited or Slippage)");
             }
        } catch {
             console.log("Quote failed for 1B USDS");
        }
        
        vm.stopPrank();
    }
}
